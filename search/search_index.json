{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Principal"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"lmsgi/","text":"Introducci\u00f3n a GIT \u00bfQu\u00e9 es un sistema de control de versiones? Un Sistema de Control de Versiones (SCV) es una aplicaci\u00f3n que permite gestionar los cambios que se realizan sobre los elementos de un proyecto o repositorio, guardando as\u00ed versiones del mismo en todas sus fases de desarrollo. Registra cada cambio en el proyecto o repositorio, qui\u00e9n y cu\u00e1ndo lo hace, en una base de datos. Permite volver a estados previos del desarrollo. Permite gestionar diferentes versiones del proyecto (ramas) para trabajar en paralelo y luego fusionarlas. Permite colaborar entre diferentes usuarios en un mismo repositorio, facilitando la resoluci\u00f3n de conflictos. Se utiliza principalmente en proyectos de desarrollo de software, pero sirve para cualquier otro tipo de proyecto. \u00bfQu\u00e9 es Git? Git es un sistema de control de versiones de c\u00f3digo abierto ideado por Linus Torvalds (el padre del sistema operativo Linux) y actualmente es el sistema de control de versiones m\u00e1s extendido. A diferencia de otros SCV, Git tiene una arquitectura distribuida, lo que significa que en lugar de guardar todos los cambios de un proyecto en un \u00fanico sitio, cada usuario contiene una copia del repositorio con el historial de cambios completo del proyecto. Esto aumenta significativamente su rendimiento. Configuraci\u00f3n de Git Comando Descripci\u00f3n git config --global user.name Establecer el nombre de usuario git config --global user.email Establecer el correo del usuario git config --global color.ui Activar el coloreado de la salida git config --global merge.conflictstyle Mostrar el estado original en los conflictos git config --list Mostrar la configuraci\u00f3n Creaci\u00f3n de un repositorio nuevo git init : Inicializa un nuevo repositorio. git init <nombre-repositorio> : Crea un repositorio con el nombre especificado. Copia de repositorios git clone <url-repositorio> : Clona un repositorio remoto en la ubicaci\u00f3n especificada. A\u00f1adir cambios a un repositorio Con Git, cualquier cambio que hagamos en un proyecto tiene que pasar por tres estados hasta que guarde definitivamente en el repositorio. Directorio de trabajo - Es el directorio que contiene una copia de una versi\u00f3n concreta del proyecto en la que se est\u00e1 trabajando. Puede contener ficheros que no pertenecen al repositorio. Zona temporal de intercambio (staging area) - es una zona donde se guardan los cambios temporalmente desde el directorio de trabajo antes de hacerlos definitivos y registrarlos en el repositorio. Repositorio - Es donde finalmente se guardan los cambios confirmados desde la zona temporal de intercambio. A\u00f1adir Cambios a la Zona de Intercambio Temporal git add <fichero> : A\u00f1ade cambios en el fichero especificado a la zona de intercambio temporal. git add <carpeta> : A\u00f1ade cambios en todos los ficheros de la carpeta especificada. git add . : A\u00f1ade todos los cambios no guardados en la zona de intercambio temporal. A\u00f1adir Cambios al Repositorio git commit -m \"mensaje\" : Confirma todos los cambios en la zona de intercambio temporal a\u00f1adi\u00e9ndolos al repositorio y creando una nueva versi\u00f3n del proyecto. \"mensaje\" es un breve mensaje describiendo los cambios realizados que se asociar\u00e1 a la nueva versi\u00f3n del proyecto. git commit --amend -m \"mensaje\" : Cambia el mensaje del \u00faltimo commit. Registro de cambios Para guardar los cambios en un repositorio Git utiliza una estructura de tres niveles : Commit : Contiene informaci\u00f3n sobre el autor, el momento y el mensaje de los cambios. \u00c1rbol (tree) : Cada commit contiene adem\u00e1s un \u00e1rbol donde se registran los nombres y rutas de los ficheros en el repositorio cuando se hizo el commit. Blob (binary file object) : Para cada uno de los ficheros listados en el \u00e1rbol hay un blob, que contiene una instant\u00e1nea comprimida del contenido del fichero cuando se hizo el commit. Si un fichero del repositorio no ha cambiado en el commit, el \u00e1rbol apunta al blob del fichero del \u00faltimo commit donde el fichero cambi\u00f3. Referenciar un commit Cada commit tiene asociado un c\u00f3digo hash de 40 caracteres hexadecimales que lo identifica de manera \u00fanica. Hay dos formas de referirse a un commit: Nombre absoluto: Se utiliza su c\u00f3digo hash (basta indicar los 4 o 5 primeros d\u00edgitos). Nombre relativo: Se utiliza la palabra HEAD para referirse siempre al \u00faltimo commit. Para referirse al pen\u00faltimo commit se utiliza HEAD~1 , al antepen\u00faltimo HEAD~2 , etc. Mostrar el estado de un repositorio git status : Muestra el estado de los cambios en el repositorio desde la \u00faltima versi\u00f3n guardada. En particular, muestra los ficheros con cambios en el directorio de trabajo que no se han a\u00f1adido a la zona de intercambio temporal y los ficheros en la zona de intercambio temporal que no se han a\u00f1adido al repositorio. Mostrar el historial de versiones de un repositorio git log : Muestra el historial de commits de un repositorio ordenado cronol\u00f3gicamente. Para cada commit muestra su c\u00f3digo hash, el autor, la fecha, la hora y el mensaje asociado. Este comando es muy vers\u00e1til y muestra la historia del repositorio en distintos formatos dependiendo de los par\u00e1metros que se le den. Los m\u00e1s comunes son: - --oneline: Muestra cada commit en una l\u00ednea produciendo una salida m\u00e1s compacta. - --graph: Muestra la historia en forma de grafo. Mostrar los datos de un commit git show : Muestra el usuario, el d\u00eda, la hora y el mensaje del \u00faltimo commit, as\u00ed como las diferencias con el anterior. git show<commit> : Muestra el usuario, el d\u00eda, la hora y el mensaje del commit indicado, as\u00ed como las diferencias con el anterior. Mostrar el historial de cambios de un fichero git annotate : Muestra el contenido de un fichero anotando cada l\u00ednea con informaci\u00f3n del commit en el que se introdujo. Cada l\u00ednea de la salida contiene los 8 primeros d\u00edgitos del c\u00f3digo hash del commit correspondiente al cambio, el autor de los cambio, la fecha, el n\u00famero de l\u00ednea del fichero y el contenido de la l\u00ednea. Mostrar las diferencias entre versiones git diff : Muestra las diferencias entre el directorio de trabajo y la zona de intercambio temporal. git diff --cached : Muestra las diferencias entre la zona de intercambio temporal y el \u00faltimo commit. git diff HEAD : Muestra la diferencia entre el directorio de trabajo y el \u00faltimo commit. Eliminar cambios del directorio de trabajo o volver a una versi\u00f3n anterior git checkout <commit> -- <file> : Actualiza el fichero <file> a la versi\u00f3n correspondiente al commit <commit> . Suele utilizarse para eliminar los cambios en un fichero que no han sido guardados a\u00fan en la zona de intercambio temporal, mediante el comando git checkout HEAD -- <file> . Eliminar cambios de la zona de intercambio temporal git reset <fichero> : Elimina los cambios del fichero <fichero> de la zona de intercambio temporal, pero preserva los cambios en el directorio de trabajo. Para eliminar por completo los cambios de un fichero que han sido guardados en la zona de intercambio temporal hay que aplicar este comando y despu\u00e9s git checkout HEAD -- <fichero> . Eliminar cambios de un commit git reset --hard <commit> : Elimina todos los cambios desde el commit <commit> y actualiza el HEAD este commit. \u00a1Ojo! Usar con cuidado este comando pues los cambios posteriores al commit indicado se pierden por completo. Suele usarse para eliminar todos los cambios en el directorio de trabajo desde el \u00faltimo commit mediante el comando git reset --hard HEAD . git reset <commit> : Actualiza el HEAD al commit <commit> , es decir, elimina todos los commits posteriores a este commit, pero no elimina los cambios del directorio de trabajo. Ramas Inicialmente, cualquier repositorio tiene una \u00fanica rama llamada master (main) , donde se van sucediendo todos los commits de manera lineal. Una de las caracter\u00edsticas m\u00e1s \u00fatiles de Git es que permite la creaci\u00f3n de ramas para trabajar en distintas versiones de un proyecto a la vez, lo que facilita el desarrollo simult\u00e1neo de nuevas funcionalidades, correcciones de errores o experimentos sin interferir con el flujo de trabajo principal. Esto es especialmente \u00fatil si se quieren a\u00f1adir nuevas funcionalidades al proyecto sin que interfieran con lo desarrollado hasta ahora, permitiendo un desarrollo m\u00e1s organizado y controlado. Una vez que se termina el desarrollo de las nuevas funcionalidades en una rama, estas se pueden fusionar con la rama principal (generalmente master) para incorporar los cambios al proyecto principal de manera ordenada y controlada, manteniendo as\u00ed la integridad del c\u00f3digo y facilitando la colaboraci\u00f3n entre los miembros del equipo. Creaci\u00f3n de ramas git branch <rama> : Crea una nueva rama con el nombre <rama> en el repositorio a partir del \u00faltimo commit, es decir, donde apunte HEAD. Al crear una rama a partir de un commit, el flujo de commits se bifurca en dos de manera que se pueden desarrollar dos versiones del proyecto en paralelo. Desarrollo en ramas diferentes Listado de ramas git log : Muestra las ramas activas de un repositorio indicando con * la rama activa en ese momento. git log --graph --oneline : Muestra la historia del repositorio en forma de grafo (--graph) incluyendo todas las ramas (--all) . Cambio de ramas git checkout <rama> : Actualiza los ficheros del directorio de trabajo a la \u00faltima versi\u00f3n del repositorio correspondiente a la rama <rama> , y la activa, es decir, HEAD pasa a apuntar al \u00faltimo commit de esta rama. git checkout -b <rama> : Crea una nueva rama con el nombre <rama> y la activa, es decir, HEAD pasa a apuntar al \u00faltimo commit de esta rama. Este comando es equivalente aplicar los comandos git branch <rama> y despu\u00e9s git checkout <rama> . Fusi\u00f3n de ramas git merge <rama> : Integra los cambios de la rama <rama> en la rama actual a la que apunta HEAD. Resoluci\u00f3n de conflictos Para fusionar dos ramas es necesario que no haya conflictos entre los cambios realizados a las dos versiones del proyecto. Si en ambas versiones se han hecho cambios sobre la misma parte de un fichero, entonces se produce un conflicto y es necesario resolverlo antes de poder fusionar las ramas. La resoluci\u00f3n debe hacerse manualmente observando los cambios que interfieren y decidiendo cuales deben prevalecer, aunque existen herramientas como KDif3 o meld que facilitan el proceso. Reorganizaci\u00f3n de ramas git rebase <rama-1> <rama-2> : Replica los cambios de la rama <rama-2> en la rama <rama-1> partiendo del ancestro com\u00fan de ambas ramas. El resultado es el mismo que la fusi\u00f3n de las dos ramas pero la bifurcaci\u00f3n de la <rama-2> desaparece ya que sus commits pasan a estar en la <rama-1> . Eliminaci\u00f3n de ramas git branch -d <rama> : Elimina la rama de nombre <rama> siempre y cuando haya sido fusionada previamente. git branch -D <rama> : Elimina la rama de nombre <rama> incluso si no ha sido fusionada. Si la rama no ha sido fusionada previamente se perder\u00e1n todos los cambios de esa rama. Repositorios remotos Adem\u00e1s de facilitar la colaboraci\u00f3n entre distintos usuarios en un proyecto mediante la gesti\u00f3n de ramas, Git permite la creaci\u00f3n de repositorios remotos , lo que ampl\u00eda a\u00fan m\u00e1s las posibilidades de trabajo colaborativo y la distribuci\u00f3n del c\u00f3digo. Git posibilita la creaci\u00f3n de una copia del repositorio en un servidor git en internet, lo que se conoce como un repositorio remoto . La principal ventaja de tener una copia remota del repositorio es que sirve como una copia de seguridad externa, lo que garantiza la integridad y disponibilidad del c\u00f3digo en caso de p\u00e9rdida o da\u00f1o en el repositorio local. Adem\u00e1s de su funci\u00f3n como copia de seguridad, los repositorios remotos permiten que otros usuarios accedan a \u00e9l y realicen cambios en el c\u00f3digo. Esto facilita la colaboraci\u00f3n entre equipos distribuidos geogr\u00e1ficamente, ya que cada miembro del equipo puede trabajar en su propia copia del repositorio y luego sincronizar los cambios con el repositorio remoto. Aunque existen varios proveedores de alojamiento para repositorios Git, el m\u00e1s popular y ampliamente utilizado es GitHub , que ofrece una plataforma robusta y completa para la gesti\u00f3n de proyectos de desarrollo de software.","title":"LMSGI"},{"location":"lmsgi/#introduccion-a-git","text":"","title":"Introducci\u00f3n a GIT"},{"location":"lmsgi/#que-es-un-sistema-de-control-de-versiones","text":"Un Sistema de Control de Versiones (SCV) es una aplicaci\u00f3n que permite gestionar los cambios que se realizan sobre los elementos de un proyecto o repositorio, guardando as\u00ed versiones del mismo en todas sus fases de desarrollo. Registra cada cambio en el proyecto o repositorio, qui\u00e9n y cu\u00e1ndo lo hace, en una base de datos. Permite volver a estados previos del desarrollo. Permite gestionar diferentes versiones del proyecto (ramas) para trabajar en paralelo y luego fusionarlas. Permite colaborar entre diferentes usuarios en un mismo repositorio, facilitando la resoluci\u00f3n de conflictos. Se utiliza principalmente en proyectos de desarrollo de software, pero sirve para cualquier otro tipo de proyecto.","title":"\u00bfQu\u00e9 es un sistema de control de versiones?"},{"location":"lmsgi/#que-es-git","text":"Git es un sistema de control de versiones de c\u00f3digo abierto ideado por Linus Torvalds (el padre del sistema operativo Linux) y actualmente es el sistema de control de versiones m\u00e1s extendido. A diferencia de otros SCV, Git tiene una arquitectura distribuida, lo que significa que en lugar de guardar todos los cambios de un proyecto en un \u00fanico sitio, cada usuario contiene una copia del repositorio con el historial de cambios completo del proyecto. Esto aumenta significativamente su rendimiento.","title":"\u00bfQu\u00e9 es Git?"},{"location":"lmsgi/#configuracion-de-git","text":"Comando Descripci\u00f3n git config --global user.name Establecer el nombre de usuario git config --global user.email Establecer el correo del usuario git config --global color.ui Activar el coloreado de la salida git config --global merge.conflictstyle Mostrar el estado original en los conflictos git config --list Mostrar la configuraci\u00f3n","title":"Configuraci\u00f3n de Git"},{"location":"lmsgi/#creacion-de-un-repositorio-nuevo","text":"git init : Inicializa un nuevo repositorio. git init <nombre-repositorio> : Crea un repositorio con el nombre especificado.","title":"Creaci\u00f3n de un repositorio nuevo"},{"location":"lmsgi/#copia-de-repositorios","text":"git clone <url-repositorio> : Clona un repositorio remoto en la ubicaci\u00f3n especificada.","title":"Copia de repositorios"},{"location":"lmsgi/#anadir-cambios-a-un-repositorio","text":"Con Git, cualquier cambio que hagamos en un proyecto tiene que pasar por tres estados hasta que guarde definitivamente en el repositorio. Directorio de trabajo - Es el directorio que contiene una copia de una versi\u00f3n concreta del proyecto en la que se est\u00e1 trabajando. Puede contener ficheros que no pertenecen al repositorio. Zona temporal de intercambio (staging area) - es una zona donde se guardan los cambios temporalmente desde el directorio de trabajo antes de hacerlos definitivos y registrarlos en el repositorio. Repositorio - Es donde finalmente se guardan los cambios confirmados desde la zona temporal de intercambio.","title":"A\u00f1adir cambios a un repositorio"},{"location":"lmsgi/#anadir-cambios-a-la-zona-de-intercambio-temporal","text":"git add <fichero> : A\u00f1ade cambios en el fichero especificado a la zona de intercambio temporal. git add <carpeta> : A\u00f1ade cambios en todos los ficheros de la carpeta especificada. git add . : A\u00f1ade todos los cambios no guardados en la zona de intercambio temporal.","title":"A\u00f1adir Cambios a la Zona de Intercambio Temporal"},{"location":"lmsgi/#anadir-cambios-al-repositorio","text":"git commit -m \"mensaje\" : Confirma todos los cambios en la zona de intercambio temporal a\u00f1adi\u00e9ndolos al repositorio y creando una nueva versi\u00f3n del proyecto. \"mensaje\" es un breve mensaje describiendo los cambios realizados que se asociar\u00e1 a la nueva versi\u00f3n del proyecto. git commit --amend -m \"mensaje\" : Cambia el mensaje del \u00faltimo commit.","title":"A\u00f1adir Cambios al Repositorio"},{"location":"lmsgi/#registro-de-cambios","text":"Para guardar los cambios en un repositorio Git utiliza una estructura de tres niveles : Commit : Contiene informaci\u00f3n sobre el autor, el momento y el mensaje de los cambios. \u00c1rbol (tree) : Cada commit contiene adem\u00e1s un \u00e1rbol donde se registran los nombres y rutas de los ficheros en el repositorio cuando se hizo el commit. Blob (binary file object) : Para cada uno de los ficheros listados en el \u00e1rbol hay un blob, que contiene una instant\u00e1nea comprimida del contenido del fichero cuando se hizo el commit. Si un fichero del repositorio no ha cambiado en el commit, el \u00e1rbol apunta al blob del fichero del \u00faltimo commit donde el fichero cambi\u00f3.","title":"Registro de cambios"},{"location":"lmsgi/#referenciar-un-commit","text":"Cada commit tiene asociado un c\u00f3digo hash de 40 caracteres hexadecimales que lo identifica de manera \u00fanica. Hay dos formas de referirse a un commit: Nombre absoluto: Se utiliza su c\u00f3digo hash (basta indicar los 4 o 5 primeros d\u00edgitos). Nombre relativo: Se utiliza la palabra HEAD para referirse siempre al \u00faltimo commit. Para referirse al pen\u00faltimo commit se utiliza HEAD~1 , al antepen\u00faltimo HEAD~2 , etc.","title":"Referenciar un commit"},{"location":"lmsgi/#mostrar-el-estado-de-un-repositorio","text":"git status : Muestra el estado de los cambios en el repositorio desde la \u00faltima versi\u00f3n guardada. En particular, muestra los ficheros con cambios en el directorio de trabajo que no se han a\u00f1adido a la zona de intercambio temporal y los ficheros en la zona de intercambio temporal que no se han a\u00f1adido al repositorio.","title":"Mostrar el estado de un repositorio"},{"location":"lmsgi/#mostrar-el-historial-de-versiones-de-un-repositorio","text":"git log : Muestra el historial de commits de un repositorio ordenado cronol\u00f3gicamente. Para cada commit muestra su c\u00f3digo hash, el autor, la fecha, la hora y el mensaje asociado. Este comando es muy vers\u00e1til y muestra la historia del repositorio en distintos formatos dependiendo de los par\u00e1metros que se le den. Los m\u00e1s comunes son: - --oneline: Muestra cada commit en una l\u00ednea produciendo una salida m\u00e1s compacta. - --graph: Muestra la historia en forma de grafo.","title":"Mostrar el historial de versiones de un repositorio"},{"location":"lmsgi/#mostrar-los-datos-de-un-commit","text":"git show : Muestra el usuario, el d\u00eda, la hora y el mensaje del \u00faltimo commit, as\u00ed como las diferencias con el anterior. git show<commit> : Muestra el usuario, el d\u00eda, la hora y el mensaje del commit indicado, as\u00ed como las diferencias con el anterior.","title":"Mostrar los datos de un commit"},{"location":"lmsgi/#mostrar-el-historial-de-cambios-de-un-fichero","text":"git annotate : Muestra el contenido de un fichero anotando cada l\u00ednea con informaci\u00f3n del commit en el que se introdujo. Cada l\u00ednea de la salida contiene los 8 primeros d\u00edgitos del c\u00f3digo hash del commit correspondiente al cambio, el autor de los cambio, la fecha, el n\u00famero de l\u00ednea del fichero y el contenido de la l\u00ednea.","title":"Mostrar el historial de cambios de un fichero"},{"location":"lmsgi/#mostrar-las-diferencias-entre-versiones","text":"git diff : Muestra las diferencias entre el directorio de trabajo y la zona de intercambio temporal. git diff --cached : Muestra las diferencias entre la zona de intercambio temporal y el \u00faltimo commit. git diff HEAD : Muestra la diferencia entre el directorio de trabajo y el \u00faltimo commit.","title":"Mostrar las diferencias entre versiones"},{"location":"lmsgi/#eliminar-cambios-del-directorio-de-trabajo-o-volver-a-una-version-anterior","text":"git checkout <commit> -- <file> : Actualiza el fichero <file> a la versi\u00f3n correspondiente al commit <commit> . Suele utilizarse para eliminar los cambios en un fichero que no han sido guardados a\u00fan en la zona de intercambio temporal, mediante el comando git checkout HEAD -- <file> .","title":"Eliminar cambios del directorio de trabajo o volver a una versi\u00f3n anterior"},{"location":"lmsgi/#eliminar-cambios-de-la-zona-de-intercambio-temporal","text":"git reset <fichero> : Elimina los cambios del fichero <fichero> de la zona de intercambio temporal, pero preserva los cambios en el directorio de trabajo. Para eliminar por completo los cambios de un fichero que han sido guardados en la zona de intercambio temporal hay que aplicar este comando y despu\u00e9s git checkout HEAD -- <fichero> .","title":"Eliminar cambios de la zona de intercambio temporal"},{"location":"lmsgi/#eliminar-cambios-de-un-commit","text":"git reset --hard <commit> : Elimina todos los cambios desde el commit <commit> y actualiza el HEAD este commit. \u00a1Ojo! Usar con cuidado este comando pues los cambios posteriores al commit indicado se pierden por completo. Suele usarse para eliminar todos los cambios en el directorio de trabajo desde el \u00faltimo commit mediante el comando git reset --hard HEAD . git reset <commit> : Actualiza el HEAD al commit <commit> , es decir, elimina todos los commits posteriores a este commit, pero no elimina los cambios del directorio de trabajo.","title":"Eliminar cambios de un commit"},{"location":"lmsgi/#ramas","text":"Inicialmente, cualquier repositorio tiene una \u00fanica rama llamada master (main) , donde se van sucediendo todos los commits de manera lineal. Una de las caracter\u00edsticas m\u00e1s \u00fatiles de Git es que permite la creaci\u00f3n de ramas para trabajar en distintas versiones de un proyecto a la vez, lo que facilita el desarrollo simult\u00e1neo de nuevas funcionalidades, correcciones de errores o experimentos sin interferir con el flujo de trabajo principal. Esto es especialmente \u00fatil si se quieren a\u00f1adir nuevas funcionalidades al proyecto sin que interfieran con lo desarrollado hasta ahora, permitiendo un desarrollo m\u00e1s organizado y controlado. Una vez que se termina el desarrollo de las nuevas funcionalidades en una rama, estas se pueden fusionar con la rama principal (generalmente master) para incorporar los cambios al proyecto principal de manera ordenada y controlada, manteniendo as\u00ed la integridad del c\u00f3digo y facilitando la colaboraci\u00f3n entre los miembros del equipo.","title":"Ramas"},{"location":"lmsgi/#creacion-de-ramas","text":"git branch <rama> : Crea una nueva rama con el nombre <rama> en el repositorio a partir del \u00faltimo commit, es decir, donde apunte HEAD. Al crear una rama a partir de un commit, el flujo de commits se bifurca en dos de manera que se pueden desarrollar dos versiones del proyecto en paralelo.","title":"Creaci\u00f3n de ramas"},{"location":"lmsgi/#desarrollo-en-ramas-diferentes","text":"","title":"Desarrollo en ramas diferentes"},{"location":"lmsgi/#listado-de-ramas","text":"git log : Muestra las ramas activas de un repositorio indicando con * la rama activa en ese momento. git log --graph --oneline : Muestra la historia del repositorio en forma de grafo (--graph) incluyendo todas las ramas (--all) .","title":"Listado de ramas"},{"location":"lmsgi/#cambio-de-ramas","text":"git checkout <rama> : Actualiza los ficheros del directorio de trabajo a la \u00faltima versi\u00f3n del repositorio correspondiente a la rama <rama> , y la activa, es decir, HEAD pasa a apuntar al \u00faltimo commit de esta rama. git checkout -b <rama> : Crea una nueva rama con el nombre <rama> y la activa, es decir, HEAD pasa a apuntar al \u00faltimo commit de esta rama. Este comando es equivalente aplicar los comandos git branch <rama> y despu\u00e9s git checkout <rama> .","title":"Cambio de ramas"},{"location":"lmsgi/#fusion-de-ramas","text":"git merge <rama> : Integra los cambios de la rama <rama> en la rama actual a la que apunta HEAD.","title":"Fusi\u00f3n de ramas"},{"location":"lmsgi/#resolucion-de-conflictos","text":"Para fusionar dos ramas es necesario que no haya conflictos entre los cambios realizados a las dos versiones del proyecto. Si en ambas versiones se han hecho cambios sobre la misma parte de un fichero, entonces se produce un conflicto y es necesario resolverlo antes de poder fusionar las ramas. La resoluci\u00f3n debe hacerse manualmente observando los cambios que interfieren y decidiendo cuales deben prevalecer, aunque existen herramientas como KDif3 o meld que facilitan el proceso.","title":"Resoluci\u00f3n de conflictos"},{"location":"lmsgi/#reorganizacion-de-ramas","text":"git rebase <rama-1> <rama-2> : Replica los cambios de la rama <rama-2> en la rama <rama-1> partiendo del ancestro com\u00fan de ambas ramas. El resultado es el mismo que la fusi\u00f3n de las dos ramas pero la bifurcaci\u00f3n de la <rama-2> desaparece ya que sus commits pasan a estar en la <rama-1> .","title":"Reorganizaci\u00f3n de ramas"},{"location":"lmsgi/#eliminacion-de-ramas","text":"git branch -d <rama> : Elimina la rama de nombre <rama> siempre y cuando haya sido fusionada previamente. git branch -D <rama> : Elimina la rama de nombre <rama> incluso si no ha sido fusionada. Si la rama no ha sido fusionada previamente se perder\u00e1n todos los cambios de esa rama.","title":"Eliminaci\u00f3n de ramas"},{"location":"lmsgi/#repositorios-remotos","text":"Adem\u00e1s de facilitar la colaboraci\u00f3n entre distintos usuarios en un proyecto mediante la gesti\u00f3n de ramas, Git permite la creaci\u00f3n de repositorios remotos , lo que ampl\u00eda a\u00fan m\u00e1s las posibilidades de trabajo colaborativo y la distribuci\u00f3n del c\u00f3digo. Git posibilita la creaci\u00f3n de una copia del repositorio en un servidor git en internet, lo que se conoce como un repositorio remoto . La principal ventaja de tener una copia remota del repositorio es que sirve como una copia de seguridad externa, lo que garantiza la integridad y disponibilidad del c\u00f3digo en caso de p\u00e9rdida o da\u00f1o en el repositorio local. Adem\u00e1s de su funci\u00f3n como copia de seguridad, los repositorios remotos permiten que otros usuarios accedan a \u00e9l y realicen cambios en el c\u00f3digo. Esto facilita la colaboraci\u00f3n entre equipos distribuidos geogr\u00e1ficamente, ya que cada miembro del equipo puede trabajar en su propia copia del repositorio y luego sincronizar los cambios con el repositorio remoto. Aunque existen varios proveedores de alojamiento para repositorios Git, el m\u00e1s popular y ampliamente utilizado es GitHub , que ofrece una plataforma robusta y completa para la gesti\u00f3n de proyectos de desarrollo de software.","title":"Repositorios remotos"},{"location":"public/proyecto/","text":"Tutorial markdown Tutorial markdown P\u00e1rrafos y destacar Texto Citado Enlaces Imagenes C\u00f3digo y bloques de c\u00f3digo CSS HTML JS Tablas listas de tareas Referencias Esquema Esquema P\u00e1rrafos y destacar Lo m\u00e1s habitual es agegar p\u00e1rrafos en lugar de saltos de l\u00ednea, de modo que el texto se adapte al contenedor en el que est\u00e1. Sin embargo, en ocasiones es preferible romper el estilo de escritura por defecto y comenzar una nueva l\u00ednea. Para agregar un salto de l\u00ednea con markdown basta con que dejes dos o m\u00e1s espacios en blanco al final de la l\u00ednea y luego pulses INTRO Texto Citado La sintaxis de los dos o m\u00e1s espacios al final de cada l\u00ednea para crear un salto de l\u00ednea funcionar\u00e1 con casi cualquier procesador de texto Markdown. Sin embargo, a la hora de editar el texto resulta complicado percibir los espacios en la mayor\u00eda de los editores. De hecho, es f\u00e1cil agregarlos sin querer al final de las oraciones. a sintaxis de los dos o m\u00e1s espacios al final de cada l\u00ednea para crear un salto de l\u00ednea funcionar\u00e1 con casi cualquier procesador de texto Markdown. Sin embargo, a la hora de editar el texto resulta complicado percibir los espacios en la mayor\u00eda de los editores. De hecho, es f\u00e1cil agregarlos sin querer al final de las oraciones. Enlaces https://tutorialmarkdown.com/sintaxis https://tutorialmarkdown.com/sintaxis Markdown Imagenes C\u00f3digo y bloques de c\u00f3digo La sintaxis de los dos o m\u00e1s var = document.querySelector(\"img\") espacios al final de cada l\u00ednea para crear un salto de l\u00ednea funcionar\u00e1 con casi cualquier procesador de texto Markdown. Sin embargo, a la hora de editar el texto resulta complicado percibir los espacios en la mayor\u00eda de los editores. De hecho, es f\u00e1cil agregarlos sin querer al final de las oraciones. CSS h1 { color: red; } HTML <h1> ejemplo html </h1> <p> lorem <a href=\"texto.html\">enlace </a> JS let x = document.querySelector(\"img\") Tablas Caberera h1 h1 h2 Elemento1 Elemento1 Elemento1 Elemento1 Elemento1 Elemento1 Elemento1 Elemento1 Elemento1 Elemento1 Elemento1 Elemento1 listas de tareas [] tarea 1 [x] tarea 2 [] tarea 3 Referencias Aprende a programar con PHP Aprende a programar con Java Aprende a programar con MD Esquema Elemento 01 Elemento 011 Elemento 02 Elemento 03 Elemento 03 Elemento 03 Esquema Elemento 01 Elemento 011 Elemento 02 Elemento 03 Elemento 03 Elemento 03","title":"Tutorial markdown"},{"location":"public/proyecto/#tutorial-markdown","text":"Tutorial markdown P\u00e1rrafos y destacar Texto Citado Enlaces Imagenes C\u00f3digo y bloques de c\u00f3digo CSS HTML JS Tablas listas de tareas Referencias Esquema Esquema","title":"Tutorial markdown"},{"location":"public/proyecto/#parrafos-y-destacar","text":"Lo m\u00e1s habitual es agegar p\u00e1rrafos en lugar de saltos de l\u00ednea, de modo que el texto se adapte al contenedor en el que est\u00e1. Sin embargo, en ocasiones es preferible romper el estilo de escritura por defecto y comenzar una nueva l\u00ednea. Para agregar un salto de l\u00ednea con markdown basta con que dejes dos o m\u00e1s espacios en blanco al final de la l\u00ednea y luego pulses INTRO","title":"P\u00e1rrafos y destacar"},{"location":"public/proyecto/#texto-citado","text":"La sintaxis de los dos o m\u00e1s espacios al final de cada l\u00ednea para crear un salto de l\u00ednea funcionar\u00e1 con casi cualquier procesador de texto Markdown. Sin embargo, a la hora de editar el texto resulta complicado percibir los espacios en la mayor\u00eda de los editores. De hecho, es f\u00e1cil agregarlos sin querer al final de las oraciones. a sintaxis de los dos o m\u00e1s espacios al final de cada l\u00ednea para crear un salto de l\u00ednea funcionar\u00e1 con casi cualquier procesador de texto Markdown. Sin embargo, a la hora de editar el texto resulta complicado percibir los espacios en la mayor\u00eda de los editores. De hecho, es f\u00e1cil agregarlos sin querer al final de las oraciones.","title":"Texto Citado"},{"location":"public/proyecto/#enlaces","text":"https://tutorialmarkdown.com/sintaxis https://tutorialmarkdown.com/sintaxis Markdown","title":"Enlaces"},{"location":"public/proyecto/#imagenes","text":"","title":"Imagenes"},{"location":"public/proyecto/#codigo-y-bloques-de-codigo","text":"La sintaxis de los dos o m\u00e1s var = document.querySelector(\"img\") espacios al final de cada l\u00ednea para crear un salto de l\u00ednea funcionar\u00e1 con casi cualquier procesador de texto Markdown. Sin embargo, a la hora de editar el texto resulta complicado percibir los espacios en la mayor\u00eda de los editores. De hecho, es f\u00e1cil agregarlos sin querer al final de las oraciones.","title":"C\u00f3digo y bloques de c\u00f3digo"},{"location":"public/proyecto/#css","text":"h1 { color: red; }","title":"CSS"},{"location":"public/proyecto/#html","text":"<h1> ejemplo html </h1> <p> lorem <a href=\"texto.html\">enlace </a>","title":"HTML"},{"location":"public/proyecto/#js","text":"let x = document.querySelector(\"img\")","title":"JS"},{"location":"public/proyecto/#tablas","text":"Caberera h1 h1 h2 Elemento1 Elemento1 Elemento1 Elemento1 Elemento1 Elemento1 Elemento1 Elemento1 Elemento1 Elemento1 Elemento1 Elemento1","title":"Tablas"},{"location":"public/proyecto/#listas-de-tareas","text":"[] tarea 1 [x] tarea 2 [] tarea 3","title":"listas de tareas"},{"location":"public/proyecto/#referencias","text":"Aprende a programar con PHP Aprende a programar con Java Aprende a programar con MD","title":"Referencias"},{"location":"public/proyecto/#esquema","text":"Elemento 01 Elemento 011 Elemento 02 Elemento 03 Elemento 03 Elemento 03","title":"Esquema"},{"location":"public/proyecto/#esquema_1","text":"Elemento 01 Elemento 011 Elemento 02 Elemento 03 Elemento 03 Elemento 03","title":"Esquema"}]}